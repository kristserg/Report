<!doctype html>
<html lang="bg">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>

<div class="paddingup">
<ul>
  <li><a href="#1">Какво е софтуерно тестване?</a></li>
  <li><a href="#2">Защо трябва да тестваме Web приложенията си?</a></li>
  <li><a href="#3">Някои видове софтуерно тестване на Web приложения</a></li>
  <li><a href="#4">Инструменти за стрес тестване на Web приложения</a></li>
  <li><a href="#5">Използвана литература</a></li>
</ul>
</div>

<div class="mainpage">
<div>
	<h1 class="heading">Инструменти за стрес тестване на Web приложения</h1>
</div>
	<p class="first" id = "1">Какво е софтуерно тестване?</p>
	<p>Тестването е един от най-важните етапи от процеса на създаване на софтуер. То се прави с цел да се получи информация за ефективността и качеството на работа на 
системата, която се тества, както и за откриване на бъгове, грешки или други дефекти в нея. Тестването е итеративен процес, тъй като при откриването и справянето 
с даден дефект, той може да отключи други след себе си. Разбира се, поради изключително голямото разнообразие от бъгове, които могат да се проявят, тестването не може 
да се справи с всички тях. Неговата главна цел обаче е да сравни очаквано с реално поведение т.е. при какви обстоятелства системата започва да действа некоректно. 
Това се извършва с помощта на, така наречените, тестови сценарии, които представляват последователности от стъпки и инструкции, които могат да се изпълнят ръчно (от 
тестъри) или автоматично (от друг софтуер).[1]</p>
	<div>
	<figure>
		<img id="testcase" src="img/testcase.png">
		<figcaption> <i> Фиг 1. - Примерен тестов сценарий за банкомат. </i> </figcaption>
	</figure>
	</div>
	
	<p class="first" id = "2">Защо трябва да тестваме Web приложенията си?</p>
	<p>Макар за мнозина тестването да не е най-приятната част от разработката на какъвто и да бил софтуер, то без него продукта може да се окаже тотално неизползваем и 
неконкурентноспособен на пазара. Това се отнася включително и за Web приложенията. Така например изследване от 2012г. между над 500 собственици на уебсайтове показва, 
че потребителския капацитет на сайтовете им е завишен <strong> над 3 пъти </strong>, а пък времето за отговор от сайтовете било <b> над 8 секунди средно при очаквани 2 </b>.[2] Друго изследване от 
2012г. показва, че <b> 68 % </b> от собствениците на уебсайтове са докладвали за проблеми със стабилността и производителността на сайтовете.[2] В същото време <b> само 30 % </b> от 
собствениците казват, че редовно подлагат сайтовете на load тестове особено преди и след като правят промени по тях.[2] Изследване на Тами Евъртс от Radware от 2013г. 
пък показва, че <b> около 18 % </b> от всички онлайн кошници за пазаруване биват изоставяни заради твърде бавно поведение на сайтовете.[2] В същото време намаляването на времето 
за отговор от 7 на 2 секунди например може да увеличи посещаемостта с <b> над 25 % </b>.[2]</p>
	<p class="first" id = "3">Някои видове софтуерно тестване на Web приложения</p>
	<p>	   Съществуват много различни видове софтуерно тестване, но тук ще бъдат разгледани само няколко, които играят изключително важна роля за разработката на уеб приложения.</p>
	<p>	   <b> Load тестването </b> е изключително полезен начин за тестване на дадено Web приложение. Чрез него се изследва поведението на приложението под някакъв "товар". Този 
"товар" може да бъде например брой потребители опитващи се да използват приложението конкурентно за някакъв период от време. Това би бил отличен начин да се види 
колко гладко би работило приложението при нормално натоварване (например ако се очаква то да се ползва от до 100 потребители едновременно, то се тества с до 100 такива).[3]</p>
	<p>	   <b> Stress тестването </b> е друг жизнено важен за Web приложенията метод за тестване. Stress тестването прилича доста на load тестването главно по това, че приложението бива 
поставено под някакво натоварване, но ако load тестването цели да изследва поведението на системата в обикновена среда с умерено натоварване, то целите на stress 
тестването са да се излезе от "комфортната зона" на натоварване и да се намерят неговите горни граници, които приложението може да понесе. Stress тестването е 
изключително важно да се прави, защото невинаги сайтовете биват подложени на нормален трафик (например онлайн магазините по време на черен петък). Друга цел на stress 
тестването е да се анализира поведението на приложението след като то е крашнало (например дали не позволява изтичане на данни и дали може да се възстанови към 
нормалното си състояние).[3] </p> 

	<div>
	<figure>
		<img id="loadvsstress" src="img/loadvsstress.png">
		<figcaption> <i> Фиг 2. - Load vs Stress тестване. </i> </figcaption>
	</figure>
	</div>
	
	<p>	   Освен load и stress тестване има и <b> performance тестване </b>, което установява как различните компоненти на системата се държат в дадена ситуация. Така например с load 
тестване може да бъде установено, че даден сайт се справя добре с 10000 потребители, но то не може да даде информация за това дали сайта работи задоволително бързо под 
такова натоварване. Тук идва ролята на performance тестването, което цели да открие и елиминира тези единични компоненти ограничаващи производителността на системата. 
Качественото performance тестване е изключително сложен процес, който зависи от много различни компоненти.[4]</p>
	
	<div>
	<figure>
		<img id="perftest" src="img/perftest.png">
		<figcaption> <i> Фиг 3. - Компоненти на Performance тестването. </i> </figcaption>
	</figure>
	</div>

	<p class="first" id = "4">Инструменти за стрес тестване на Web приложения</p>
	
	<h2> 1. Selenium </h2>
	
	<div>
	<figure>
		<img id="sellogo" src="img/sel.png">
		<figcaption> <i> Фиг 4. - Selenium лого. </i> </figcaption>
	</figure>
	</div>
	
	<p> <b> Selenium </b> е една от най-популярните структури от инструменти за автоматично stress и load тестване. Подходящ е за почти всички браузъри и операционни системи и може да 
бъде контролиран от много различни езици за програмиране. Selenium разполага и с доста инструменти, които позволяват още по-голямо качество в процеса по load и stress 
тестване (например SeleniumWebDriver и SeleniumGrid). Той е open-source софтуер и може да се изтегли и използва без заплащане.[5]</p>
	<div>
	<figure>
		<img id="seladv" src="img/seladv.png">
		<figcaption> <i> Фиг 5. - Предимствата на Selenium. </i> </figcaption>
	</figure>
	</div>
	
	<h2> 2. Apache JMeter™ </h2>
	
	<div>
	<figure>
		<img id="apjmlogo" src="img/apjm.png">
		<figcaption> <i> Фиг 6. - Apache JMeter™ лого. </i> </figcaption>
	</figure>
	</div>

	<p> <b> Apache JMeter™ </b> е най-използваният open source инструмент за load и stress тестване през 2017г. Оригинално създаден за тестване на Web или FTP приложения, днес той може да се ползва
за функционални тестове, тестове върху сървърите с бази данни и тн. Начинът, по който JMeter работи е описан на картинката: </p> 

	<div>
	<figure>
		<img id="apjmwork" src="img/jmwork.png">
		<figcaption> <i> Фиг 7. - Начин на работа на Apache JMeter™. </i> </figcaption>
	</figure>
	</div>

<p> Основните предимства на JMeter са свързани с това, че е open source, работи на почти всички платформи, има приятелски потребителски интерфейс с 3 режима - GUI, Server и 
Command Line. JMeter също показва резултатите от тестовете по много различни начини - чрез таблици, графики, дървета и тн. Той поддържа всички основни протоколи като 
например HTTP, SOAP, LDAP, JDBC, JMS и FTP. JMeter може да бъде интегриран към друг инструмент за автоматично тестване като например Selenium и Bean Shell. Поддържа 
multi-threading и позволява да се тестват паралелно много потребители (за stress тестване). Разполага също така с опции за "записване" и "плейбек", които записват 
и възпроизвеждат поведение на потребител в браузъра. Част от слабостите на JMeter са, че не може да записва HTTPS комуникация и не може да прави статистики за работата 
на сървъра на приложението.[6] </p>

	<h2> 3. The Grinder </h2>
	
	<div>
	<figure>
		<img id="grinderlogo" src="img/grinder.jpg">
		<figcaption> <i> Фиг 8. - The Grinder лого. </i> </figcaption>
	</figure>
	</div>

	<p> <b> The Grinder </b> е популярен Java framework използван за load и stress тестване. Скриптовият език, който той ползва е Jython - Java имплементация на Python, а може да се 
поддържа и Clojure. Главните части на The Grinder са Grinder конзолата и Grinder агентите. Конзолата служи за разработка и редактиране на тестове, за следене 
на резултатите от тях в реално време и за контролиране на различните Grinder агенти. Grinder агентите пък са съвкупност от специални генератори на "товар", наречени 
работници (workers). На картинката може да се види stress тест с The Grinder: </p> 

	<div>
	<figure>
		<img id="grinderwf" src="img/grinderstress.png">
		<figcaption> <i> Фиг 9. - Stress тестване с The Grinder. </i> </figcaption>
	</figure>
	</div>

<p> Основни предимства на The Grinder са, че работи на почти всички платформи (Java базиран е), поддържа множество различни протоколи, има гъвкава параметризация и позволява 
на потребителите да пишат свои plug-ins. Главните му недостатъци са свързани с това, че не разполага с допълнителни анализиращи инструменти, както и с това, че е нужно 
познание по Jython или Clojure, за да бъде използван.[6] </p>

	<h2> 4. Gatling </h2>
	
	<div>
	<figure>
		<img id="gatling" src="img/Gatling.png">
		<figcaption> <i> Фиг 10. - Gatling лого. </i> </figcaption>
	</figure>
	</div>

	<p> <b> Gatling </b> е най-силният Scala-базиран инструмент за load и stress тестване. Съдържа 2 изпълними файла: един за създаване на тестови сценарии и един за изпълненията им.
Основните предимства на Gatling са свързани с това, че работи с почти всички операционни системи и браузъри, предлага цветни и информативни графични доклади от 
проведените тестове, които съдържат и ценна информация за анализ. С него могат да се изпълняват тестове в различни тестови облачни среди. Той може също така да бъде 
лесно интегриран към Jenkins чрез специален plug-in, a може и да изпълнява тестове чрез Gradle и Maven отново с помощта на съответните plug-ins. Gatling се нуждае и от 
много малко памет, редуцира времето за дебъгване и детектира грешки и дефекти още на много ранен етап. Най-големият недостатък на Gatling е, че API-тата му са се 
променили драстично с времето и може тестове на стари версии да не тръгват на по-новите.[6]</p>

	<h2> 5. Locust </h2>
	
	<div>
	<figure>
		<img id="locust" src="img/locust.png">
		<figcaption> <i> Фиг 11. - Locust лого. </i> </figcaption>
	</figure>
	</div>

	<p> <b> Locust </b> е разпределен инструмент за load и stress тестване написан на Python. Потребителите на даден сайт тук се наричат "скакалци" (locusts) и поведението на всеки един 
от тях може да бъде дефинирано от програмиста. След това "ятото скакалци" се пуска и процесите, които се наблюдават в системата, в резултат на действието на ятото, могат 
да бъдат наблюдавани в реално време, което спомага за по-лесното идентифициране на слабите места в приложението. Някои от предимствата на Locust са, че всяка система 
може да бъде тествана на него, работи на всички платформи и може да симулира поведението на стотици потребители едновременно. Минусите на този инструмент са свързани 
най-вече със съхранението на статистика.[6] </p>

	<h2> 6. Siege </h2>

	<p> <b> Siege </b> е друг инструмент за load и stress тестване поддържащ HTTP, HTTPS и FTP протоколи. Разработен е за GNU/Linux системи, но може да бъде пригоден и за AIX, Solaris, 
HP-UX и BSD. Някои от качествата, които го нареждат сред най-добрите инструменти са това, че поддържа много различни протоколи и бисквитки, лесно се компилира на 
Unix-базирани операционни системи, позволява multi-threading и може да бъде пуснат с различни IP адреси от една и съща машина. За недостатък на Siege в сравнение с 
другите инструменти може да се счита това, че не може да бъде подкаран на Windows (всъщност може, но е необходим друг специален инструмент наречен Cygwin).[6] </p>

	<h2> 7. Pylot </h2>
	
	<div>
	<figure>
		<img id="pylot" src="img/Pylot.png">
		<figcaption> <i> Фиг 12. - Pylot лого. </i> </figcaption>
	</figure>
	</div>

	<p> <b> Pylot </b> е безплатен open-source инструмент за тестване на приозводителността и мащабираността на Web приложения. Негов плюс е това, че поддържа HTTP load тестове, 
които са полезни за планирания, бенчмаркинг и други видове анализ.[7] </p>

	<h2> 8. BlazeMeter </h2>
	
	<div>
	<figure>
		<img id="blazemeter" src="img/blazemeter.png">
		<figcaption> <i> Фиг 13. - BlazeMeter лого. </i> </figcaption>
	</figure>
	</div>

	<p> <b> BlazeMeter </b> е една от най-популярните платформи за load и stress тестване. Има я в платен, както и в безплатен вариант като разликата е, че в безплатния може да се пускат 
тестове с не повече от 50 потребителя и има само един генератор на "товар". Предимства на BlazeMeter са, че е съвместим с JMeter и лесно може да се интегрира към други 
популярни open source инструменти като Selenium, Locust и Gatling. В платената версия има възможност за тестване с до 1 милион потребители. BlazeMeter разполага и с 
възможност за симулиране на трафик от мобилни устройства с променящо се качество на сигнала. Главният му недостатък е това, че е платен и безплатната му версия е силно 
орязана откъм възможности.[6] </p>

	<p class="first" id = "5">Използвана литература</p>
	<h2> Списък с цитирана литература </h2>
	<ol class="list">
		<li>https://en.wikipedia.org/wiki/Software_testing</li> последно посетен на 12.12.17г.
		<li>https://loadimpact.com/website-testing</li> последно посетен на 12.12.17г.
		<li>https://stackoverflow.com/questions/9750509/load-vs-stress-testing</li> последно посетен на 12.12.17г.
		<li>https://prateekvjoshi.com/2013/08/21/why-do-we-need-performance-testing/</li> последно посетен на 12.12.17г.
		<li>http://docs.seleniumhq.org</li> последно посетен на 12.12.17г.
		<li>https://geteasyqa.com/blog/best-tools-load-testing/</li> последно посетен на 12.12.17г.
		<li>https://www.devcurry.com/2010/07/10-free-tools-to-loadstress-test-your.html</li> последно посетен на 12.12.17г.
	</ol>
	
	<h2> Списък с фигури </h2>
	<ol class="list">
		<li>Примерен тестов сценарий за банкомат.</li>
		<li>Load vs Stress тестване.</li>
		<li>Компоненти на Performance тестването.</li>
		<li>Selenium лого.</li>
		<li>Предимствата на Selenium.</li>
		<li>Apache JMeter™ лого.</li>
		<li>Начин на работа на Apache JMeter™.</li> 
		<li>The Grinder лого.</li>
		<li>Stress тестване с The Grinder.</li>
		<li>Gatling лого.</li>
		<li>Locust лого.</li>
		<li>Pylot лого.</li>
		<li>BlazeMeter лого.</li>
	</ol>
	
</div>
</body>
</html>

